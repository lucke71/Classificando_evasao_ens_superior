from ies_df t1
)tab
where ano_max=ano
),
evasao as (
select 	tab1.*,
1 as evasao
from(
select 	t1.*,
count(co_ocde_area_geral) over (partition by co_aluno) as num_grupos,
count(case when co_aluno_situacao=4 then 1 end) over (partition by co_aluno) as num_desvinc,
count(case when co_aluno_situacao=5 then 1 end) over (partition by co_aluno) as num_transf
from ult_sit t1
)tab1
where (num_desvinc=num_grupos) or (num_transf+num_desvinc = num_grupos)
union all
select 	tab2.*,
0 as evasao
from(
select 	t2.*,
count(co_ocde_area_geral) over (partition by co_aluno) as num_grupos,
count(case when co_aluno_situacao=4 then 1 end) over (partition by co_aluno) as num_desvinc,
count(case when co_aluno_situacao=5 then 1 end) over (partition by co_aluno) as num_transf
from ult_sit t2
)tab2
where not((num_desvinc=num_grupos) or (num_transf+num_desvinc = num_grupos))
)"
},"
select 	tab2.co_ies,
tab2.co_curso,
tab2.semestre_ingresso,
tab2.vagas,
tab2.candidatos,
tab2.co_grau_academico,
tab2.co_nivel_academico,
tab2.co_ocde_area_geral,
tab2.areas_3,
tab2.ABI,
tab2.in_integral_curso,
tab2.in_matutino_curso,
tab2.in_vespertino_curso,
tab2.in_noturno_curso,
tab2.nu_integralizacao_integral,
tab2.nu_integralizacao_matutino,
tab2.nu_integralizacao_vespertino,
tab2.nu_integralizacao_noturno,
tab2.co_nacionalidade_aluno,
tab2.co_aluno_situacao,
tab2.in_reserva_vagas,
tab2.in_bolsa_estagio,
tab2.in_bolsa_monitoria,
tab2.in_bolsa_pesquisa,
tab2.in_bolsa_extensao,
tab2.num_ies,
tab2.ano_max,
tab2.evasao,
tab2.doc_exercicio,
tab2.doc_qualifcacao,
tab2.doc_exer_outro_org,
tab2.doc_afastado_outro,
tab2.doc_falecido,
tab2.doc_sem_grad,
tab2.doc_graduacao,
tab2.doc_especializacao,
tab2.doc_mestrado,
tab2.doc_doutorado,
tab2.doc_integ_de,
tab2.doc_integ_sem_de,
tab2.doc_temp_parcial,
tab2.doc_horista,
tab2.doc_brasileiro,
tab2.doc_brasileiro_nat,
tab2.doc_estrangeiro,
--atributos ENEM
tab2.in_estuda_classe_hospitalar,
tab2.cod_municipio_residencia,
tab2.cod_municipio_esc,
tab2.id_dependencia_adm_esc,
tab2.id_localizacao_esc,
tab2.sit_func_esc,
tab2.idade,
tab2.tp_sexo,
tab2.nacionalidade,
tab2.cod_municipio_nascimento,
tab2.st_conclusao,
tab2.ano_concluiu,
tab2.tp_escola,
tab2.in_tp_ensino,
tab2.tp_estado_civil,
tab2.tp_cor_raca,
tab2.in_baixa_visao,
tab2.in_cegueira,
tab2.in_surdez,
tab2.in_deficiencia_auditiva,
tab2.in_surdo_cegueira,
tab2.in_deficiencia_fisica,
tab2.in_deficiencia_mental,
tab2.in_deficit_atencao,
tab2.in_dislexia,
tab2.in_gestante,
tab2.in_lactante,
tab2.in_idoso,
tab2.in_autismo,
tab2.in_sabatista,
tab2.in_braille,
tab2.in_ampliada_24,
tab2.in_ampliada_18,
tab2.in_ledor,
tab2.in_acesso,
tab2.in_transcricao,
tab2.in_libras,
tab2.in_leitura_labial,
tab2.in_mesa_cadeira_rodas,
tab2.in_mesa_cadeira_separada,
tab2.in_guia_interprete,
tab2.in_certificado,
tab2.cod_municipio_prova,
tab2.nu_nota_comp1,
tab2.nu_nota_comp2,
tab2.nu_nota_comp3,
tab2.nu_nota_comp4,
tab2.nu_nota_comp5,
tab2.nu_nota_redacao,
tab2.q001,
tab2.q002,
tab2.q003,
tab2.q004,
tab2.q005,
tab2.q006,
tab2.q007,
tab2.q008,
tab2.q009,
tab2.q010,
tab2.q011,
tab2.q012,
tab2.q013,
tab2.q014,
tab2.q015,
tab2.q016,
tab2.q017,
tab2.q018,
tab2.q019,
tab2.q020,
tab2.q021,
tab2.q022,
tab2.q023,
tab2.q024,
tab2.q025,
tab2.q026,
tab2.q027,
tab2.q028,
tab2.q029,
tab2.q030,
tab2.q031,
tab2.q032,
tab2.q033,
tab2.q034,
tab2.q035,
tab2.q036,
tab2.q037,
tab2.q038,
tab2.q039,
tab2.q040,
tab2.q041,
tab2.q042,
tab2.q043,
tab2.q044,
tab2.q045,
tab2.q046,
tab2.q047,
tab2.q048,
tab2.q049,
tab2.q050,
tab2.q051,
tab2.q052,
tab2.q053,
tab2.q054,
tab2.q055,
tab2.q056,
tab2.q057,
tab2.q058,
tab2.q059,
tab2.q060,
tab2.q061,
tab2.q062,
tab2.q063,
tab2.q064,
tab2.q065,
tab2.q066,
tab2.q067,
tab2.q068,
tab2.q069,
tab2.q070,
tab2.q071,
tab2.q072,
tab2.q073,
tab2.q074,
tab2.q075,
tab2.q076
from(
select	distinct
tab.*,
--enem_empilhado
t2.nu_ano,
t2.id_inscricao,
t2.id_mascara,
t2.in_estuda_classe_hospitalar,
t2.cod_municipio_residencia,
t2.cod_municipio_esc,
t2.id_dependencia_adm_esc,
t2.id_localizacao_esc,
t2.sit_func_esc,
t2.idade,
t2.tp_sexo,
t2.nacionalidade,
t2.cod_municipio_nascimento,
t2.st_conclusao,
t2.ano_concluiu,
t2.tp_escola,
t2.in_tp_ensino,
t2.tp_estado_civil,
t2.tp_cor_raca,
t2.in_baixa_visao,
t2.in_cegueira,
t2.in_surdez,
t2.in_deficiencia_auditiva,
t2.in_surdo_cegueira,
t2.in_deficiencia_fisica,
t2.in_deficiencia_mental,
t2.in_deficit_atencao,
t2.in_dislexia,
t2.in_gestante,
t2.in_lactante,
t2.in_idoso,
t2.in_autismo,
t2.in_sabatista,
t2.in_braille,
t2.in_ampliada_24,
t2.in_ampliada_18,
t2.in_ledor,
t2.in_acesso,
t2.in_transcricao,
t2.in_libras,
t2.in_leitura_labial,
t2.in_mesa_cadeira_rodas,
t2.in_mesa_cadeira_separada,
t2.in_guia_interprete,
t2.in_certificado,
t2.cod_municipio_prova,
t2.nu_nota_comp1,
t2.nu_nota_comp2,
t2.nu_nota_comp3,
t2.nu_nota_comp4,
t2.nu_nota_comp5,
t2.nu_nota_redacao,
t2.q001,
t2.q002,
t2.q003,
t2.q004,
t2.q005,
t2.q006,
t2.q007,
t2.q008,
t2.q009,
t2.q010,
t2.q011,
t2.q012,
t2.q013,
t2.q014,
t2.q015,
t2.q016,
t2.q017,
t2.q018,
t2.q019,
t2.q020,
t2.q021,
t2.q022,
t2.q023,
t2.q024,
t2.q025,
t2.q026,
t2.q027,
t2.q028,
t2.q029,
t2.q030,
t2.q031,
t2.q032,
t2.q033,
t2.q034,
t2.q035,
t2.q036,
t2.q037,
t2.q038,
t2.q039,
t2.q040,
t2.q041,
t2.q042,
t2.q043,
t2.q044,
t2.q045,
t2.q046,
t2.q047,
t2.q048,
t2.q049,
t2.q050,
t2.q051,
t2.q052,
t2.q053,
t2.q054,
t2.q055,
t2.q056,
t2.q057,
t2.q058,
t2.q059,
t2.q060,
t2.q061,
t2.q062,
t2.q063,
t2.q064,
t2.q065,
t2.q066,
t2.q067,
t2.q068,
t2.q069,
t2.q070,
t2.q071,
t2.q072,
t2.q073,
t2.q074,
t2.q075,
t2.q076,
max(t2.nu_ano) over (partition by t2.nu_cpf) as ano_max2
from evasao tab
inner join enem_empilhado t2 on tab.nu_cpf=t2.nu_cpf and tab.ano>=t2.nu_ano
) tab2
where ano_max2=nu_ano
)"
))
}
rm(cria_tabela_evasao())
rm(cria_tabela_evasao
)
rm(classificando_evasao)
classify_dropout = function(database,cv_folds=4,pct_training=0.75,classificador="CART",num_cores=4,balanceamento=""){
# Argumentos da funcao que sao obrigatorios: database --- escolher o dataframe que possui os dados de evasao a serem utilizados;
# Os outros argumentos possuem valores padrao.
# Classificador padrao: CART; Opcoes: "CART" (executa apenas classificador CART),
# "C45" (executa apenas classificador C4.5), "NB" (executa apenas classificador Naive Bayes), "reglog" (executa apenas classificador de regressao logistica),
# "Nnet" (executa apenas classificador de redes neurais) e "todos" (executa todos os classificadores)
# Numero de folds para cross-validation padrao e 4; Opcoes: qualquer numero maior que zero
# Percentual da base a ser usada para treinamento padrao = 75% (25% sao usados para teste); Opcoes: qualquer percentual (valores de 0 a 1)
# Numero de cores a ser usado caso OS seja baseado em UNIX padrao = 4; As opcoes dependem da maquina em que esta sendo executado
# Fazer balanceamento dos dados padrao e nao fazer balanceamento. Opcoes: "up"para up-sampling e "down" para down-sampling
# Depende de dplyr, caret e doParallel (UNIX)
classify_dropout = function(database,cv_folds=4,pct_training=0.75,classificador="CART",num_cores=4,balanceamento=""){
library(dplyr)
library(caret)
# indicar quais atributos sao factors
attr_nao_factor = c("vagas","candidatos","num_ies","idade","ano_max","ano_concluiu","nu_nota_comp1","nu_nota_comp2","nu_nota_comp3","nu_nota_comp4","nu_nota_comp5","nu_nota_redacao","doc_exercicio","doc_qualifcacao","doc_exer_outro_org","doc_afastado_outro","doc_falecido","doc_graduacao","doc_especializacao","doc_mestrado","doc_doutorado","doc_integ_de","doc_integ_sem_de","doc_temp_parcial","doc_horista","doc_brasileiro","doc_brasileiro_nat","doc_estrangeiro")
nao_factor_pos = sapply(attr_nao_factor,function(x)grep(paste0("^",x,"$"),names(database)))
nao_factor_pos = unlist(nao_factor_pos)
var_factor = (1:ncol(database))[-nao_factor_pos]
# funcao para remover espacos antes e depois de respostas
tira_espaco = function (x) gsub("^\\s+|\\s+$", "", x)
# funcao para trocar valores vazios ("") por "branco"
val_branco = function (x) sub("^$","branco",x)
# funcao para trocar o valor NA por "branco"
val_NA = function (x) ifelse(is.na(x),"branco",x)
# aplicando funcao trim nos atributos que sao "fatores"
database[,var_factor] = lapply(database[,var_factor],tira_espaco)
# aplicando funcao val_branco nos atributos que sao "fatores"
database[,var_factor] = lapply(database[,var_factor],val_branco)
# aplicando funcao val_branco nos atributos que sao "fatores"
database[,var_factor] = lapply(database[,var_factor],val_NA)
if(any(grepl("cod_municipio_residencia",names(database))) & any(grepl("cod_municipio_nascimento",names(database))) & any(grepl("cod_municipio_prova",names(database)))){
# removendo municipios de nascimento e de escola - criando atributo indicativo de municipios diferentes
database = database %>% mutate(mun_nasc_dif_res = cod_municipio_nascimento!=cod_municipio_residencia)
database = database %>% mutate(mun_res_dif_esc = cod_municipio_residencia!=cod_municipio_esc)
database = database %>% mutate(mun_res_dif_prova = cod_municipio_residencia!=cod_municipio_prova)
database = database %>% mutate(uf_res = substr(cod_municipio_residencia,1,2))
database = database %>% mutate(uf_esc = substr(cod_municipio_esc,1,2))
database = database %>% mutate(uf_nasc = substr(cod_municipio_nascimento,1,2))
database = dplyr::select(database,-c(cod_municipio_residencia,cod_municipio_esc,cod_municipio_prova,cod_municipio_nascimento))
}
if(any(grepl("ano_concluiu",names(database)))){
# adicionando atributo dummy para indicar se aluno concluiu ensino medio e adicionando zero ao ano de conclusao caso nao tenha concluido
database$concluiu_ens_med = ifelse(is.na(database$ano_concluiu),FALSE,TRUE)
database$ano_concluiu[is.na(database$ano_concluiu)] = 0
}
# atualizando a posicao dos atributos fatores
nao_factor_pos = sapply(attr_nao_factor,function(x)grep(paste0("^",x,"$"),names(database)))
nao_factor_pos = unlist(nao_factor_pos)
var_factor = (1:ncol(database))[-nao_factor_pos]
# transformando os atributos em factors
database[,var_factor] = lapply(database[,var_factor],factor,exclude=NULL)
# Removendo missing
database = na.omit(database)
# Removendo as colunas que nao possuem variancia - as colunas a ser retiradas pode variar de acordo com os dados
nzv = nearZeroVar(database)
database = database[,-nzv]
# Determinando o tipo de controle a ser feito sobre os modelos
fitcontrol = trainControl(method = "cv",number = cv_folds,summaryFunction = twoClassSummary)
# Numero de nucleos para processamento paralelo (LINUX) -- Para windows usar Microsoft R OPEN
if(Sys.info()[1]=="Linux")library(doParallel);registerDoParallel(cores = num_cores)
# Separando base de treinamento da base de teste
intraining = createDataPartition(database$evasao, p = pct_training, list = FALSE)
base_treina = database[intraining,]
base_teste = database[-intraining,]
# Fazendo as classificacoes com upsampling na base de treinamento
if(balanceamento=="up"){
up_data = upSample(x = dplyr::select(base_treina,-evasao), y = base_treina$evasao,yname="evasao")
}
# Downsampling
if(balanceamento=="down"){
dwn_data = downSample(x = dplyr::select(base_treina,-evasao), y = base_treina$evasao,yname="evasao")
}
# Classificando com Naive Bayes
if(classificador=="todos" | classificador=="NB"){
if(balanceamento=="up"){
naive_fit <<- train(x = dplyr::select(up_data,-evasao),y=up_data$evasao,method="nb",trControl=fitcontrol,metric = 'Spec')
}else if(balanceamento=="down"){
naive_fit <<- train(x = dplyr::select(dwn_data,-evasao),y=dwn_data$evasao,method="nb",trControl=fitcontrol,metric = 'Spec')
}else{
naive_fit <<- train(x = dplyr::select(base_treina,-evasao),y=base_treina$evasao,method="nb",trControl=fitcontrol,metric = 'Spec')
}
naive_pred <<- predict(naive_fit,base_teste)
mc_naive <<- confusionMatrix(naive_pred,base_teste$evasao)
}
# Classificando com CART
if(classificador=="todos" | classificador=="CART"){
if(balanceamento=="up"){
cart_fit <<- train(x = dplyr::select(up_data,-evasao),y=up_data$evasao,method="rpart",trControl=fitcontrol,tuneLength = 10,maxdepth=30,metric = 'Spec')
}else if(balanceamento=="down"){
cart_fit <<- train(x = dplyr::select(dwn_data,-evasao),y=dwn_data$evasao,method="rpart",trControl=fitcontrol,tuneLength = 10,maxdepth=30,metric = 'Spec')
}else{
cart_fit <<- train(x = dplyr::select(base_treina,-evasao),y=base_treina$evasao,method="rpart",trControl=fitcontrol,tuneLength = 10,maxdepth=30,metric = 'Spec')
}
cart_pred <<- predict(cart_fit,base_teste)
mc_cart <<- confusionMatrix(cart_pred,base_teste$evasao)
}
# Classificando com C4.5
if(classificador=="todos" | classificador=="C45"){
if(balanceamento=="up"){
c45_fit <<- train(x=dplyr::select(up_data,-evasao),y=up_data$evasao,method="J48",tuneLength = 10,trControl=fitcontrol,metric = 'Spec')
}else if(balanceamento=="down"){
c45_fit <<- train(x=dplyr::select(dwn_data,-evasao),y=dwn_data$evasao,method="J48",tuneLength = 10,trControl=fitcontrol,metric = 'Spec')
}else{
c45_fit <<- train(x=dplyr::select(base_treina,-evasao),y=base_treina$evasao,method="J48",tuneLength = 10,trControl=fitcontrol,metric = 'Spec')
}
c45_pred <<- predict(c45_fit,base_teste)
mc_c45 <<- confusionMatrix(c45_pred,base_teste$evasao)
}
# Classificando com regressao logistica
if(classificador=="todos" | classificador=="reglog"){
if(balanceamento=="up"){
if(any(grepl("co_curso",names(database)))){
base_log <<- dplyr::select(up_data,-co_curso)
}else{base_log=up_data}
reglog_fit <<- train(evasao ~ .,data=base_log ,method="glm",family=binomial(link="logit"),trControl=fitcontrol,metric = 'Spec')
}else if(balanceamento=="down"){
if(any(grepl("co_curso",names(database)))){
base_log <<- dplyr::select(dwn_data,-co_curso)
}else{base_log=up_data}
reglog_fit <<- train(evasao ~ .,data=base_log ,method="glm",family=binomial(link="logit"),trControl=fitcontrol,metric = 'Spec')
}else{
if(any(grepl("co_curso",names(database)))){
base_log <<- dplyr::select(base_treina,-co_curso)
}else{base_log=up_data}
reglog_fit <<- train(evasao ~ .,data=base_log ,method="glm",family=binomial(link="logit"),trControl=fitcontrol,metric = 'Spec')
}
reg_pred <<- predict(reglog_fit,base_teste)
mc_reg <<- confusionMatrix(reg_pred,base_teste$evasao)
}
# Classificando com redes neurais
if(classificador=="todos" | classificador=="Nnet"){
if(balanceamento=="up"){
if(any(grepl("co_curso",names(database)))){
nnet_fit <<- train(x=dplyr::select(up_data,-c(evasao,co_curso)),y=up_data$evasao,method="nnet",trControl=fitcontrol,metric = 'Spec', maxit=1000)
}else{nnet_fit <<- train(x=dplyr::select(up_data,-evasao),y=up_data$evasao,method="nnet",trControl=fitcontrol,metric = 'Spec', maxit=1000)}
}else if(balanceamento=="down"){
if(any(grepl("co_curso",names(database)))){
nnet_fit <<- train(x=dplyr::select(dwn_data,-c(evasao,co_curso)),y=dwn_data$evasao,method="nnet",trControl=fitcontrol,metric = 'Spec', maxit=1000)
}else{nnet_fit <<- train(x=dplyr::select(dwn_data,-evasao),y=dwn_data$evasao,method="nnet",trControl=fitcontrol,metric = 'Spec', maxit=1000) }
}else{
if(any(grepl("co_curso",names(database)))){
nnet_fit <<- train(x=dplyr::select(base_treina,-c(evasao,co_curso)),y=base_treina$evasao,method="nnet",trControl=fitcontrol,metric = 'Spec', maxit=1000)
}else{nnet_fit <<- train(x=dplyr::select(base_treina,-evasao),y=base_treina$evasao,method="nnet",trControl=fitcontrol,metric = 'Spec', maxit=1000) }
}
nnet_pred <<- predict(nnet_fit,base_teste)
mc_nnet <<- confusionMatrix(nnet_pred,base_teste$evasao)
}
}
package.skeleton(name="Classify.dropout",list=c("classify_dropout","create_dropout_database","db_example"))
package.skeleton(name="Classify.dropout",list=c("classify_dropout","create_dropout_database","db_example"))
db_example = select(tb_exemplo,-c(co_aluno_situacao,co_ies,co_curso,ano_max,idade,tp_sexo,nacionalidade,cod_municipio_esc,cod_municipio_residencia,cod_municipio_nascimento,cod_municipio_prova))
tb_exemplo = dbGetQuery(con,"select * from unb_curso_completo")
library(RPostgreSQL)
library(dplyr)
# loads the PostgreSQL driver
drv <- dbDriver("PostgreSQL")
# creates a connection to the postgres database
# note that "con" will be used later in each connection to the database
con <- dbConnect(drv, dbname = "lucas_assis",
host = "localhost", port = 5432,
user = "lucas_assis", password = "139755")
tb_exemplo = dbGetQuery(con,"select * from unb_curso_completo")
tb_exemplo = tb_exemplo[sample(1:nrow(tb_exemplo),1000),]
db_example = select(tb_exemplo,-c(co_aluno_situacao,co_ies,co_curso,ano_max,idade,tp_sexo,nacionalidade,cod_municipio_esc,cod_municipio_residencia,cod_municipio_nascimento,cod_municipio_prova))
rm(tb_exemplo)
rm(con)
rm(drv)
package.skeleton(name="Classify.dropout",list=c("classify_dropout","create_dropout_database","db_example"))
